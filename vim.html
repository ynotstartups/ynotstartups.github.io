<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Vim</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="styles.css" />
  <link rel="icon" href="https://d392viioakuayd.cloudfront.net/public/favicon.webp">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Vim</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#vim---reference" id="toc-vim---reference">Vim -
Reference</a></li>
<li><a href="#regular-expression" id="toc-regular-expression">regular
expression</a>
<ul>
<li><a href="#reminders" id="toc-reminders">Reminders</a></li>
<li><a href="#definition-of-a-pattern-in-vim"
id="toc-definition-of-a-pattern-in-vim">Definition of a pattern in
vim</a></li>
</ul></li>
<li><a href="#regular-expression-character-classes-and-atoms"
id="toc-regular-expression-character-classes-and-atoms">regular
expression character classes and atoms</a>
<ul>
<li><a href="#character-classes" id="toc-character-classes">Character
Classes</a></li>
<li><a href="#atoms-special-characters"
id="toc-atoms-special-characters">Atoms / Special Characters</a></li>
</ul></li>
<li><a href="#vim9script" id="toc-vim9script">vim9script</a>
<ul>
<li><a href="#vim9script-examples"
id="toc-vim9script-examples">vim9script examples</a>
<ul>
<li><a href="#vim-function-and-variable-var"
id="toc-vim-function-and-variable-var">vim function and variable
<code>var</code></a></li>
<li><a href="#example-function-implementation"
id="toc-example-function-implementation">Example function
implementation</a></li>
<li><a href="#using-python-in-vim" id="toc-using-python-in-vim">Using
python in vim</a></li>
<li><a href="#running-a-vimscript-file-foo.vim"
id="toc-running-a-vimscript-file-foo.vim">running a vimscript file
foo.vim</a></li>
</ul></li>
</ul></li>
<li><a href="#vim---how-to" id="toc-vim---how-to">Vim - How To</a></li>
<li><a href="#open-errors-in-quickfix"
id="toc-open-errors-in-quickfix">open errors in quickfix</a></li>
<li><a href="#find-mapping-source" id="toc-find-mapping-source">find
mapping source</a></li>
<li><a href="#find-out-default-python"
id="toc-find-out-default-python">find out default python</a></li>
<li><a href="#match-on-the-second-occurrence"
id="toc-match-on-the-second-occurrence">match on the second
occurrence</a></li>
<li><a href="#print-manual-page-in-color"
id="toc-print-manual-page-in-color">print manual page in color</a></li>
<li><a href="#extract-manpage-table-of-content"
id="toc-extract-manpage-table-of-content">extract manpage table of
content</a></li>
<li><a href="#run-python-in-vim-terminal"
id="toc-run-python-in-vim-terminal">run python in vim terminal</a></li>
<li><a href="#registers-macros" id="toc-registers-macros">registers
&amp; macros</a></li>
<li><a href="#apply-changes-to-lines-match-a-pattern"
id="toc-apply-changes-to-lines-match-a-pattern">apply changes to lines
match a pattern</a></li>
<li><a href="#vim.eval-in-vim-python"
id="toc-vim.eval-in-vim-python"><code>vim.eval</code> in vim
python</a></li>
<li><a href="#vim---explanation" id="toc-vim---explanation">Vim -
Explanation</a></li>
<li><a href="#terminal-color-scheme"
id="toc-terminal-color-scheme">terminal color scheme</a></li>
<li><a href="#dont-use-as-pager-or-man-page-reader"
id="toc-dont-use-as-pager-or-man-page-reader">don’t use as pager or man
page reader</a></li>
<li><a href="#gq-formatoption" id="toc-gq-formatoption"><code>gq</code>
formatoption</a></li>
</ul>
</nav>
<h1 id="vim---reference">Vim - Reference</h1>
<h1 id="regular-expression">regular expression</h1>
<h3 id="reminders">Reminders</h3>
<ul>
<li><code>\zs</code>, <code>ze</code>, modify the start or end of regex
match, can make replacing or searching easier
<ul>
<li>e.g. <code>\zs</code> can replace positive look
behind<code>@&lt;=</code></li>
<li>e.g. <code>\ze</code> can replace positive look ahead
<code>@=</code></li>
</ul></li>
<li><code>\_.</code> matches all characters and <strong>end of
line</strong>, useful for multiline matching
<ul>
<li><code>.</code> matches all characters but not end of line</li>
</ul></li>
<li><code>\w</code> matches word characters, same as
<code>[0-9A-Za-z_]</code></li>
<li><code>\s</code> matches space or tab</li>
<li><code>\{-}</code> non-greedy match, match as little as possible,
this is a multi
<ul>
<li>basically the non-greedy version of <code>*</code></li>
</ul></li>
</ul>
<p><strong>Intresting Examples</strong></p>
<ul>
<li><code>\(def\s\)\@&lt;!foo_function(\_.\{-})</code> matches function
usage and params single line or multi lines, but <strong>not</strong>
the function definition</li>
<li><code>def\s\w*(\zs\_.\{-}\ze)</code> matches only params in function
definitions, single line or multi lines</li>
</ul>
<h3 id="definition-of-a-pattern-in-vim">Definition of a pattern in
vim</h3>
<ul>
<li><strong>atom</strong>: <code>a</code> an ordinary character,
<code>\i</code> a character class, <code>\(foo\)</code> putting
<strong>pattern</strong> in parenthesis making it an atom</li>
<li><strong>piece</strong>: <strong>atom</strong> +
<strong>multi</strong>, <code>*</code>, <code>\{n,m}</code>,
<code>{-}</code>
<ul>
<li>special <strong>multi</strong>, look ahead <code>\@=</code>,
<code>\@!</code>, look behind
<code>\@&lt;=</code>,<code>\@&lt;!</code>,</li>
</ul></li>
<li><strong>concat</strong>: <strong>piece</strong> +
<strong>piece</strong>, <code>a*b*</code></li>
<li><strong>branch</strong>: <strong>concat</strong> <code>\&amp;</code>
<strong>concat</strong>, <code>\&amp;</code> means matching both regex
patterns, like <em>AND</em></li>
<li><strong>pattern</strong>: <strong>branch</strong> <code>\|</code>
<strong>branch</strong>, <code>\|</code> means either patterns, like
<em>OR</em></li>
</ul>
<h1 id="regular-expression-character-classes-and-atoms">regular
expression character classes and atoms</h1>
<h2 id="character-classes">Character Classes</h2>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 26%" />
<col style="width: 30%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr>
<th>Character classes</th>
<th>Python</th>
<th>Rg</th>
<th>Vim</th>
</tr>
</thead>
<tbody>
<tr>
<td>Word char</td>
<td><code>\w</code></td>
<td>same</td>
<td><code>\w</code></td>
</tr>
<tr>
<td>Space</td>
<td><code>\s</code></td>
<td>same</td>
<td><code>\s</code></td>
</tr>
<tr>
<td>Multiline</td>
<td><code>re.DOTALL</code> / <code>(?s)</code></td>
<td><code>--multiline</code> or <code>(?s)</code></td>
<td><code>\_.</code></td>
</tr>
</tbody>
</table>
<h2 id="atoms-special-characters">Atoms / Special Characters</h2>
<table>
<thead>
<tr>
<th>Atoms</th>
<th>Python</th>
<th>Rg</th>
<th>Vim</th>
</tr>
</thead>
<tbody>
<tr>
<td>zero or more</td>
<td><code>?</code></td>
<td>same</td>
<td><code>?</code></td>
</tr>
<tr>
<td>1 or more</td>
<td><code>+</code></td>
<td>same</td>
<td><code>+</code></td>
</tr>
<tr>
<td>precise number of matches</td>
<td><code>{n,m}</code></td>
<td>same</td>
<td><code>{n,m}</code></td>
</tr>
<tr>
<td>word boundary</td>
<td><code>\b</code></td>
<td>same</td>
<td><code>&lt; &gt;</code></td>
</tr>
<tr>
<td>multiple patterns or</td>
<td><code>|</code></td>
<td>same</td>
<td><code>|</code></td>
</tr>
<tr>
<td>non greedy</td>
<td><code>.*?</code></td>
<td>same</td>
<td><code>.{-}</code></td>
</tr>
<tr>
<td>line starts with</td>
<td><code>^</code></td>
<td>same</td>
<td><code>^</code></td>
</tr>
<tr>
<td>line ends with</td>
<td><code>$</code></td>
<td>same</td>
<td><code>$</code></td>
</tr>
<tr>
<td>group</td>
<td><code>( )</code></td>
<td>same</td>
<td><code>( )</code></td>
</tr>
<tr>
<td>back reference</td>
<td><code>\1 \2 \3</code></td>
<td></td>
<td><code>\1 \2 \3</code></td>
</tr>
<tr>
<td>set start of match</td>
<td></td>
<td></td>
<td><code>\zs</code></td>
</tr>
<tr>
<td>set end of match</td>
<td></td>
<td></td>
<td><code>\ze</code></td>
</tr>
</tbody>
</table>
<p>Example: to match <code>company</code> and <code>companies</code></p>
<ul>
<li>vim: <code>compan\(y\|ies\)</code></li>
<li>rg: <code>compan(y|ies)</code></li>
</ul>
<h1 id="vim9script">vim9script</h1>
<h2 id="vim9script-examples">vim9script examples</h2>
<h3 id="vim-function-and-variable-var">vim function and variable
<code>var</code></h3>
<pre class="vim"><code># vim9script reminder
# use `var` to define variable, instead of `let`

# boolean
true
false

# option value &amp;foo 
echo &amp;number
# assigns value to option
&amp;number = 1

# contents of register `q`
echo @q
# remove or set contents of register `q`
@q = &quot;&quot;
# set register q in linewise mode
setreg(&#39;q&#39;, &#39;&#39;, &#39;V&#39;)

# string concatenation
var foo = &quot;abc&quot; .. &quot;def&quot;
# string interpolation
var name = &quot;tiger&quot;
echo $&quot;hello {name}!&quot;

# setting variable name to register
# @0 is last yanked text
var name = @0

# list
var foo_list = [1, 2, 3]
var first_item = foo_list[0]
var first_two_items = foo_list[0 : 2]
var last_two_items = foo_list[-2 : ]
# list concatenation
var foo_list_extended = foo_list + [4, 5] 
# builtin list methods
mylist-&gt;add(val1)-&gt;add(val2)
mylist-&gt;copy()
mylist-&gt;count(val)
mylist-&gt;empty()
mylist-&gt;extend(otherlist)
mylist-&gt;filter(expr2)
mylist-&gt;flatten()
mylist-&gt;foreach(expr2)
mylist-&gt;indexof(expr)
mylist-&gt;insert(item)
mylist-&gt;join()
mylist-&gt;len()
mylist-&gt;map(expr2)
mylist-&gt;max()
mylist-&gt;min()
mylist-&gt;remove(idx)
mylist-&gt;repeat(count)
mylist-&gt;reverse()
mylist-&gt;sort()
mylist-&gt;string()
mylist-&gt;type()
mylist-&gt;uniq()

# dictionary
var foo = {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3}
echomsg foo[&quot;a&quot;]
for [key, value] in foo-&gt;items()
    echomsg key value
endfor
# dictionary methods
mydict-&gt;has_key(key)
mydict-&gt;items()
mydict-&gt;keys()
mydict-&gt;values()

# if
var a = 1.5
if a &gt; 2
    echo &quot;a &gt; 2&quot; a
elseif a &gt; 1
    echo &quot;a &gt; 1&quot; a
else
    echo &quot;a &lt; 1&quot; a
endif

# for loop
var foo = [1, 2, 3]
for i in foo
    echo i
endfor

# regex match, right hand side string is used as a pattern
# echo true
echo &quot;foo&quot; =~ &#39;^f.*&#39;
# echo false
echo &quot;foo&quot; =~ &#39;b.*&#39;

# powerful commands

# execute the string from the evaluation of {expr1} as an cli # command
execute &quot;normal @q&quot;

# calling vim builtin function, see `:help builtin.txt`
# see help for builtin function `substitute` at `:help substitude()`
var remove_prefix = substitute(posix_file_path, &#39;^saltus/&#39;, &#39;&#39;, &#39;g&#39;)

# Types

float, string, bool, number, float, string, blob, list&lt;type&gt;, dict&lt;type&gt;, job,
channel, func</code></pre>
<h3 id="example-function-implementation">Example function
implementation</h3>
<pre class="vim"><code>def GetWordAfterPrefix(prefix_string: string): string
  # search for the line number and column number for the prefix_string
  # e.g. the line and column of character &#39;f&#39; in `def \zsfoo` 
  # flag `b` - search backward  
  # flag `n` - do not move the cursor
  # see also `:help search()`
  var [match_line_number, match_col_number] = (prefix_string .. &#39;\zs&#39;)-&gt;searchpos(&#39;bn&#39;)
  var line = getline(match_line_number)
  # get the word with matching column position - 1, `-1` is needed to include
  # the first character of the word, e.g. word would be `foo`
  var word = line-&gt;matchstr(&#39;\w*&#39;, match_col_number - 1)
  return word
enddef

def g:YankWordAfterPrefix(prefix_string: string)
  var word = GetWordAfterPrefix(prefix_string)
  echom &#39;yanked&#39; word
  setreg(&#39;+&#39;, word)
enddef

nnoremap &lt;leader&gt;yf :call YankWordAfterPrefix(&quot;def &quot;)&lt;cr&gt;
nnoremap &lt;leader&gt;yc :call YankWordAfterPrefix(&quot;class &quot;)&lt;cr&gt;

def GetPythonFileImportPath(): string
    var posix_file_path = expand(&quot;%&quot;)
    var python_import_path = posix_file_path
                                -&gt;substitute(&#39;^saltus/&#39;, &#39;&#39;, &#39;g&#39;)
                                -&gt;substitute(&#39;.py$&#39;, &#39;&#39;, &#39;g&#39;)
                                -&gt;substitute(&#39;/&#39;, &#39;.&#39;, &#39;g&#39;)
    return python_import_path
enddef</code></pre>
<h3 id="using-python-in-vim">Using python in vim</h3>
<pre class="vim"><code>def g:JumpToTestFile()
py3 &lt;&lt; EOF
from vim_python import get_or_create_alternative_file

# vim.eval(&quot;@%&quot;) gets the filepath in current buffer
test_filepath = get_or_create_alternative_file(filepath=vim.eval(&quot;@%&quot;))

# open test_filepath in current window
vim.command(f&quot;tabnew {test_filepath}&quot;)
EOF
enddef</code></pre>
<h3 id="running-a-vimscript-file-foo.vim">running a vimscript file
foo.vim</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> cat <span class="ex">foo.vim</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ex">vim9script</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="ex">var</span> a = [1, 2, 3]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ex">echomsg</span> a</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> vim <span class="ex">-S</span> foo.vim</span></code></pre></div>
<h1 id="vim---how-to">Vim - How To</h1>
<h1 id="open-errors-in-quickfix">open errors in quickfix</h1>
<ol type="1">
<li>in Vim, run command
<code>:cexpr system('command that returns quickfix format')</code></li>
<li>in Terminal,
<code>vim -q &lt;(command that returns quickfix error format)</code></li>
</ol>
<p>Example for quickfix format</p>
<pre class="vim"><code>./lambdas/atr_notification/__init__.py:1:1: F401 &#39;json&#39; imported but unused
./lambdas/atr_notification/__init__.py:2:1: F401 &#39;boto3&#39; imported but unused
./lambdas/atr_notification/__init__.py:4:1: F401 &#39;lambdas.common.config.oneview.SNS_TARGET_ARN&#39; imported but unused</code></pre>
<h1 id="find-mapping-source">find mapping source</h1>
<ul>
<li><code>:verbose nmap ]]</code> - to find out which file that mapping
is defined in. From there you should be able to figure out which plugin
that file is a part of</li>
</ul>
<p>Useful resources on how to do mappings below</p>
<p>https://vim.fandom.com/wiki/Mapping_keys_in_Vim_-<em>Tutorial</em>(Part_2)</p>
<p>https://learnvimscriptthehardway.stevelosh.com/chapters/30.html</p>
<h1 id="find-out-default-python">find out default python</h1>
<ul>
<li><code>:py3 import os;print(os.__file__)</code> - print path of
python
<ul>
<li>/opt/homebrew/Cellar/python@3.11/3.11.4_1/Frameworks/Python.framework/Versions/3.11/lib/python3.11/os.py</li>
<li>using the system python at the n fmoment</li>
</ul></li>
</ul>
<h1 id="match-on-the-second-occurrence">match on the second
occurrence</h1>
<p>For example, I want to match on the second <code>&lt;</code> of the
following line</p>
<pre><code>cnoremap &lt;c-j&gt;   &lt;down&gt;
cnoremap &lt;c-k&gt;   &lt;up&gt;
cnoremap &lt;up&gt;    &lt;nop&gt;
cnoremap &lt;down&gt;  &lt;nop&gt;
cnoremap &lt;left&gt;  &lt;nop&gt;
cnoremap &lt;right&gt; &lt;nop&gt;</code></pre>
<p>Uses pattern <code>&lt;.*\zs&lt;</code></p>
<ul>
<li><code>&lt;</code> - matches the first <code>&lt;</code></li>
<li><code>.*</code> - greedy matches everything after</li>
<li><code>\zs</code> - resets the start of the pattern matches (a vim
specific pattern)</li>
<li><code>&lt;</code> - matches the second <code>&lt;</code></li>
</ul>
<p><strong>Bonus:</strong></p>
<p><code>sed -n 's/&lt;.*\(&lt;\)/\1/p'</code> changes
<code>cnoremap &lt;c-j&gt;   &lt;down&gt;</code> to
<code>cnoremap &lt;down&gt;</code>, something like delete the first
<code>&lt;&gt;</code></p>
<p><code>sed -n 's/\(&lt;.*\)&lt;.*&gt;/\1/p'</code> changes
<code>cnoremap &lt;c-j&gt;   &lt;down&gt;</code> to
<code>cnoremap &lt;c-j&gt;</code>, something like delete the second
<code>&lt;&gt;</code></p>
<h1 id="print-manual-page-in-color">print manual page in color</h1>
<ol type="1">
<li>Use <code>Vim</code> with <code>:Man</code>, you will need
<code>runtime ftplugin/man.vim</code></li>
<li>open man page with <code>:Man date</code></li>
<li>In zshrc <code>export MANWIDTH=80</code>, this sets the width to 80
so that the man page can fit in one page with correct paragraph
indent</li>
<li><code>:TOhtml</code> (P.S. I have my own
<code>:TOPrintHtml</code>)</li>
<li>then open with web browser and print</li>
</ol>
<h1 id="extract-manpage-table-of-content">extract manpage table of
content</h1>
<pre class="man"><code>ZSHMISC(1)                   General Commands Manual                  ZSHMISC(1)
NAME
       zshmisc - everything and then some
SIMPLE COMMANDS &amp; PIPELINES
       A simple command is a sequence of optional parameter assignments followed
       ...
PRECOMMAND MODIFIERS
       A simple command may be preceded by a precommand modifier, which will
       ...</code></pre>
<p>I would like the extract a Table of Content from manual page such as
below</p>
<pre class="man"><code>SIMPLE COMMANDS &amp; PIPELINES
PRECOMMAND MODIFIERS</code></pre>
<ol type="1">
<li><code>:redir @a</code> - setup redirect to register
<code>a</code></li>
<li><code>:g/^\u.*/p</code> - find all lines start with upper case and
print them</li>
<li><code>:redir END</code> - end the redirection</li>
<li><code>"ap</code> - paste content in register a</li>
</ol>
<h1 id="run-python-in-vim-terminal">run python in vim terminal</h1>
<pre class="vim"><code>:py3 print(&#39;abc&#39;)

# to change lines in range
:&#39;&lt;,&#39;&gt;py3do return line.split(&quot;:&quot;)[0] + &#39; = &#39; + line.split(&quot;:&quot;)[0].strip() + &#39;,&#39;

# run foo.py in current directory, have access to all vim_python objects
# see `:help python-command`
:pyfile foo.py

# For example
#
# &gt; cat foo.py
# vim.command(&#39;buffers a&#39;)
# for b in vim.buffers:
#     print(b)
#     print(b.__dir__())
#     print(b.valid)
# visible_buffers = [window.buffer for window in vim.current.tabpage.windows]</code></pre>
<h1 id="registers-macros">registers &amp; macros</h1>
<ul>
<li><p><code>"kp</code> - paste from register k</p></li>
<li><p><code>"Kyy</code> - append to register k by using capital
register letter <code>K</code></p></li>
<li><p><code>"0p</code> - paste from last yanked test</p></li>
<li><p><code>qk</code> - start to record macro in register
<code>k</code></p></li>
<li><p><code>[count]@k</code> - apply macro in register <code>k</code>,
[count] number of times</p></li>
<li><p><code>@@</code> - apply last macro</p></li>
</ul>
<h1 id="apply-changes-to-lines-match-a-pattern">apply changes to lines
match a pattern</h1>
<ul>
<li><code>:g/foo/d</code> - delete lines with pattern foo in this file,
<code>d</code> is the abbreviation of <code>:delete</code> command</li>
<li><code>:g/foo/normal Q</code> - apply macro on lines with pattern foo
in this file</li>
</ul>
<h1 id="vim.eval-in-vim-python"><code>vim.eval</code> in vim python</h1>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_import_path_given_word(vim: <span class="bu">object</span>) <span class="op">-&gt;</span> <span class="bu">str</span> <span class="op">|</span> <span class="va">None</span>:</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    word <span class="op">=</span> vim.<span class="bu">eval</span>(<span class="st">&#39;expand(&quot;&lt;cword&gt;&quot;)&#39;</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> package, words <span class="kw">in</span> package_and_word.items():</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> word <span class="kw">in</span> words:</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>            import_string <span class="op">=</span> <span class="ss">f&quot;from </span><span class="sc">{</span>package<span class="sc">}</span><span class="ss"> import </span><span class="sc">{</span>word<span class="sc">}</span><span class="ss">&quot;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(import_string)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> import_string</span></code></pre></div>
<p>This function above is used in <code>vim_python.py</code> imported
into vim.</p>
<p>The <code>vim.eval</code> literally runs the string passed in as vim
code and export the vim object into python object</p>
<p>For example, the following two vim commands are equivalent.</p>
<pre><code>:py3 print(vim.eval(&#39;expand(&quot;&lt;cword&gt;&quot;)&#39;))
:echom expand(&quot;&lt;cword&gt;&quot;)</code></pre>
<p>See also <code>:help if_pyth.txt</code> # regex look ahead /
behind</p>
<p><strong>Find expression A where expression B follows</strong></p>
<p><code>\@=</code> e.g. <code>\A\(B\)\@=</code></p>
<p>might be easier to use <code>\ze</code></p>
<p><strong>Find expression A where expression B does not
follow</strong></p>
<p><code>\@!</code> e.g. <code>A\(B\)\@!</code></p>
<p><strong>Find expression A where expression B is behind:</strong></p>
<p><code>\@&lt;=</code> e.g. <code>\(B\)\@&lt;=A</code></p>
<p>might be easier to use <code>\zs</code></p>
<p><strong>Find expression A where expression B is not
behind:</strong></p>
<p><code>\@&lt;!</code> e.g. <code>\(B\)\@&lt;!A</code></p>
<p><strong>For example</strong></p>
<pre><code>foo(
def foo(</code></pre>
<p>to match only function definitions, e.g. the <code>foo</code> after
def</p>
<p><code>\(def[ ]\)\@&lt;=foo(</code></p>
<p>to match function usage e.g. the <code>foo</code> not after
<code>def</code></p>
<p><code>\(def[ ]\)\@&lt;!foo(</code></p>
<pre><code>foobar
foobaz</code></pre>
<p><code>foo\(bar\)\@=</code> - matches foo that follows with bar
e.g. matches first</p>
<p><code>foo\(bar\)\@!</code> - matches foo that not follows with bar
e.g. matches second</p>
<h1 id="vim---explanation">Vim - Explanation</h1>
<h1 id="terminal-color-scheme">terminal color scheme</h1>
<p>I learn that I should enable my true color support which makes
molokai color theme much better to see.</p>
<p><code>set termguicolors</code></p>
<p><strong>Useful links</strong></p>
<p><a href="https://github.com/termstandard/colors">Test your terminal
color</a> <a
href="https://github.com/tomasr/molokai/blob/master/colors/molokai.vim">molokai
color scheme</a></p>
<h1 id="dont-use-as-pager-or-man-page-reader">don’t use as pager or man
page reader</h1>
<p>Vim doesn’t intepret ansi sequences good enough, see the following
photo.</p>
<figure>
<img src="images/vim-man-page.png" alt="vim-man-page" />
<figcaption aria-hidden="true">vim-man-page</figcaption>
</figure>
<h1 id="gq-formatoption"><code>gq</code> formatoption</h1>
<p>Current formatoption for markdown is <code>formatoption=jtln</code>
from <code>set formatoptions?</code></p>
<pre><code>                        *fo-j*</code></pre>
<p>j Where it makes sense, remove a comment leader when joining lines.
For example, joining: int i; // the index ~ // in the list ~ Becomes:
int i; // the index in the list ~</p>
<pre><code>                        *fo-t*</code></pre>
<p>t Auto-wrap text using ‘textwidth’</p>
<pre><code>                        *fo-l*</code></pre>
<p>l Long lines are not broken in insert mode: When a line was longer
than ‘textwidth’ when the insert command started, Vim does not
automatically format it.</p>
<pre><code>                        *fo-n*</code></pre>
<p>n When formatting text, recognize numbered lists. This actually uses
the ‘formatlistpat’ option, thus any kind of list can be used. The
indent of the text after the number is used for the next line. The
default is to find a number, optionally followed by ‘.’, ‘:’, ‘)’, ‘]’
or ‘}’. Note that ‘autoindent’ must be set too. Doesn’t work well
together with “2”. Example: &gt; 1. the first item wraps 2. the second
item</p>
</body>
</html>
